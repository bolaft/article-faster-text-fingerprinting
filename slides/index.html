<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Faster Text Fingerprinting</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hugo Mougard et Soufian Salim">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/beige.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
      document.write('<link rel="stylesheet" href="css/print/' + (window.location.search.match(/print-pdf/gi) ? 'pdf' : 'paper') + '.css" type="text/css" media="print">');
    </script>

    <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <section data-state="soothe">
            <h1>Introduction</h1>
          </section>

          <section>
            <h3>Qu'est ce qu'une fingerprint ?</h3>
	    <p>Pour $s = s_1 .. s_n \in \Sigma^*$, la fingerprint $f$
              sur $[i,j]$ est $\{c | c \in s_i .. s_j\}$.</p>
	    <p>Par exemple, la fingerprint sur $[6,10]$ de
	      $« M_1A_2S_3T_4E_5R_6␣_7A_8T_9A_{10}L_{11} »$ est
	      $\{␣,A,R,T\}$</p>
	    <p>Le fingerprinting de $s$ consiste à calculer les
	      fingerprints de toutes les sous-chaînes de $s$.</p>
          </section>

          <section>
            <h3>Applications possibles (1/2)</h3>
            <h4>De manière générale</h4>
	    <p>Les fingerprints sont utiles
	      quand l'on souhaite travailler sur des <b>ensembles</b> de
	      caractéristiques plutôt que des <b>séquences</b> de
	      caractéristiques.</p>
	    <h4>Intuition TAListe</h4>
	    <p>Les fingerprint sont aux ensembles ce que les n-grams
	    sont aux séquences.</p>
          </section>

          <section>
            <h3>Applications possibles (2/2)</h3>
            <h4>En bio-informatique</h4>
	    <p>Recherche approchée de chaîne de caractères.</p>
            <h4>En traitement des langues</h4>
	    <p>Intéressant pour apprendre une distribution
	      ensembliste pour un classificateur.</p>
          </section>

          <section>
            <h3>Problèmes associés aux fingerprints</h3>
	    <ol>
	      <li>Calculer l'ensemble $\mathcal{F}$ des
		fingerprints</li>
	      <li>Décider si une fingerprint $\mathcal{f}$ est dans
	      $\mathcal{F}$</li>
	      <li>Retrouver les occurrences de $f$ dans $s$</li>
	      <li>Calculer le nombre de fingerprints de taille $k$
	      dans $s$</li>
	      <li>…</li>
	    </ol>
          </section>

          <section>
            <h3>Portée de l'article</h3>
	    <p>Cet article s'intéresse au problème 1 : calculer
	      l'ensemble des fingerprints.</p>
          </section>

          <section>
            <h3>Avant de commencer</h3>

            <br>

            Deux notions à connaître pour comprendre l'apport de l'article sur le problème du calcul de $\mathcal{F}$ :<br>
            <br>

            <ul>
              <li>Les locations maximales</li>
              <li>Les copies et les classes d'équivalence</li>
            </ul>
          </section>

          <section>
            <h3>Locations maximales</h3>

            <ul>
              <li>On note $\mathcal{C}$ un ensemble de lettres de $\Sigma$. Une location maximale de $\mathcal{C}$ dans $s$ est un intervalle $[i,j]$ tel que :<br>
                <br>
                <ul>
                  <li>$\mathcal{C}_{s}(i,j) = \mathcal{C}$</li>
                  <li>Si $i > 1$, $s_{i-1} \notin$ $\mathcal{C}_{s}(i,j)$</li>
                  <li>Si $j < n$, $s_{j+1} \notin$ $\mathcal{C}_{s}(i,j)$</li>
                </ul><br>
              </li>
              <li>On note $\mathcal{L}$ l'ensemble des locations maximales de tous les fingerprints de $\mathcal{F}$</li>
            </ul>
          </section>

          <section>
            <h3>Exemple</h3>
            <br>
            $s = a_{1} b_{2} c_{3} a_{4} a_{5} d_{6} d_{7} b_{8}$<br>
            <br>
            $\mathcal{C} = abc$<br>
            <br>
            Locations maximales : {$\langle1,5\rangle$}
          </section>

          <section>
            <h3>Copies et classes d'équivalence</h3>

            <br>

            <ul>
              <li>Deux locations maximales $\langle i,j \rangle$ et $\langle k,l \rangle$ de $s$ sont des copies si $s_{i}..s_{j} = s_{k}..s_{l}$</li>
              <li>On note $\mathcal{L}_{\mathcal{C}}$ l'ensemble des classes d'équivalence</li>
            </ul>
          </section>

          <section>
            <h3>Exemple</h3>
            <br>
            $s = a_{1} b_{2} a_{3} d_{4} a_{5} b_{6} a_{7}$<br>
            <br>
            $\langle1,3\rangle$ et $\langle5,7\rangle$ sont des copies
          </section>

          <section>
            <h3>Pour le calcul de la complexité...</h3>
            <br>
            <div class="fragment">|$\mathcal{F}| \neq |\mathcal{L}| \neq |\mathcal{L}_{\mathcal{C}}|$</div>
            <br>
            <div class="fragment">|$\mathcal{F}| \leq |\mathcal{L}| \leq |\mathcal{L}_{\mathcal{C}}|$</div>
          </section>

          <section>
            <h3>Calculer $\mathcal{F}$ : état de l'art</h3>

            <style type="text/css">
              .table td {
                border-top: 1px solid black;
                padding: 10px;
              }
            </style>

            <br>

            <small>
              <table class="table">
                <thead>
                  <th>Solution</th>
                  <th>Espace (bits)</th>
                  <th>Temps</th>
                </thead>
                <tr>
                  <td>Various Impr. to T. F. (Monte-Carlo)</td>
                  <td>$\mathcal{O}((n + |\mathcal{F}|)$ $log$ $n)$</td>
                  <td>$\mathcal{O}(n + |\mathcal{L}|)$</td>
                </tr>
                <tr>
                  <td>Faster T. F.</td>
                  <td>$\mathcal{O}((n + |\mathcal{L}_{\mathcal{C}}| + |\mathcal{F}|$ $log$ $|\Sigma|)$ $log$ $n)$</td>
                  <td>$\mathcal{O}(n + |\mathcal{L}_{\mathcal{C}}|$ $log$ $|\Sigma|)$</td>
                </tr>
                <tr>
                  <td>New Algorithms for T. F.</td>
                  <td>$\mathcal{O}((n + |\mathcal{L}|)$ $log$ $n)$</td>
                  <td>$\mathcal{O}(n + |\mathcal{L}|$ $log$ $|\Sigma|)$</td>
                </tr>
                <tr>
                  <td>Efficient T. F. via Parikh Mapping</td>
                  <td>$\mathcal{O}(n|\Sigma|log$ $n$ $log$ $|\Sigma|)$</td>
                  <td></td>
                </tr>
              </table>
            </small>
          </section>

          <section>
            <h3>Passage de $|\mathcal{L}|$ à $|\mathcal{L}_{\mathcal{C}}|$ : nouvelle méthode</h3>

            <!--
              TODO méthode introduite dans l'article (intuition méthodes précendentes vs cet article)
              (par opposition au tableau + liste changements)
              (ne pas recalculer les parties redondantes des fp) 
            -->
          </section>

          <section>
            <h3>Vue d'ensemble de la méthode</h3>

          	<ul>
      			  <li>Construire l'arbre des suffixes de $s$</li>
      			  <li>À partir de l'arbre des suffixes, construire un arbre des participations</li>
      			  <li>À partir de l'arbre des participations, nommer et retourner tous les fingerprints de $s$</li>
          	</ul>
          </section>
        </section>

        <section>
          <section data-state="submerge">
            <h1>Participation Tree</h1>
          </section>
          <section>
            <h3>Principes</h3>

            <ul>
            	<li>Noté $PT$</li>
            	<li>Construit à partir de l'arbre des suffixes de $s$</li>
            	<li>Contient l'ensemble des fingerprints $f$ de $\mathcal{F}$</li>
            </ul>
          </section>
          
          <section>
            <h3>Construction de l'arbre</h3>
          </section>
          
          <section>
            <h3>Théorème</h3>

            $\Phi$ étant définie comme une fonction retournant l'ensemble des locations maximales correspondant à un chemin $z$ de $PT$,<br>
            <br>
            <b>toutes les locations maximales sont dans l'image $\Phi(z)$ d'un chemin $z$ dans $PT(s = s_{1}..s_{n})$, et la taille de $PT(s)$ est $\mathcal{O}(|\mathcal{L}_{\mathcal{C}}|)$</b>
          </section>

          <section>
            <h3>Du suffix tree au participation tree (1/2)</h3>
	    <h4>Idées</h4>
	    <ul>
	      <li>Calculer les participations des branches aux
		fingerprints les unes après les autres</li>
	      <li>Marquer les arêtes calculées pour ne pas les recalculer</li>
	      <li>Calculer seulement les deltas des valeurs
		nécessaires à chaque pas</li>
	      </ul>
	    <img src="img/suffix-tree.svg"> <span style="position:
	    relative; top: -150px;">→</span> <img src="img/participation-tree.svg">
          </section>

          <section>
            <h3>Du suffix tree au participation tree (2/2)</h3>
	    <h4>Algorithme</h4>
	    <pre><code data-trim>
		Construire_PT(ST)
  1.  Calculer chaque première occurrence depuis s₁
  2.  Trouver l'occurrence suivante de s₁
  3.  Pour i de 1 à n faire :
  4.      courant ← Feuille i dans ST
  5.      Tant que courant n'est pas marqué et n'est pas la racine :
  6.          précédent ← Parent de courant dans ST
  7.          Calculer la participation de l'arête (précédent, courant)
  8.          Marquer courant
  9.          courant ← précédent
  10.         Calculer chaque première occurrence depuis sᵢ₊₁
  11.     Fin du tant que
  12. Fin du pour
	    </code></pre>
          </section>
        </section>

        
        <section>
          <section data-state="sunset">
            <h1>Nommage des <span>fingerprints</span></h1>
          </section>

          <section>
            <h3>Nommage d'une fingerprint</h3>
          </section>

          <section>
            <h3>Nommage basique (2003)</h3>
          </section>

          <section>
            <h3>Nommage par changements</h3>
          </section>

          <section>
            <h3>Nommage sur l'arbre</h3>
          </section>
        </section>
        
        <section data-state="cobalt">
          <h1>Conclusion</h1>
        </section>
      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>
      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
      controls: true,
      progress: true,
      history: true,
      center: true,

      theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
      transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/fade/none

      math: {
      mathjax: 'http://cdn.mathjax.org/mathjax/latest/MathJax.js',
      config: 'TeX-AMS_HTML-full' // See http://docs.mathjax.org/en/latest/config-files.html
      },
      // Parallax scrolling
      // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
      // parallaxBackgroundSize: '2100px 900px',

      // Optional libraries used to extend on reveal.js
      dependencies: [{
      src: 'lib/js/classList.js',
      condition: function() {
      return !document.body.classList;
      }
      }, {
      src: 'plugin/markdown/marked.js',
      condition: function() {
      return !!document.querySelector('[data-markdown]');
      }
      }, {
      src: 'plugin/markdown/markdown.js',
      condition: function() {
      return !!document.querySelector('[data-markdown]');
      }
      }, {
      src: 'plugin/highlight/highlight.js',
      async: true,
      callback: function() {
      hljs.initHighlightingOnLoad();
      }
      }, {
      src: 'plugin/zoom-js/zoom.js',
      async: true,
      condition: function() {
      return !!document.body.classList;
      }
      }, {
      src: 'plugin/notes/notes.js',
      async: true,
      condition: function() {
      return !!document.body.classList;
      }
      }, {
      src: 'plugin/math/math.js',
      async: true
      }]
      });
    </script>

  </body>

</html>
