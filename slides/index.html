<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Faster Text Fingerprinting</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hugo Mougard et Soufian Salim">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/beige.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
      document.write('<link rel="stylesheet" href="css/print/' + (window.location.search.match(/print-pdf/gi) ? 'pdf' : 'paper') + '.css" type="text/css" media="print">');
    </script>

    <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <section data-state="soothe">
            <h1>Introduction</h1>
          </section>

          <section>
            <h3>Qu'est ce qu'un fingerprint ?</h3>
          </section>

          <section>
            <h3>Applications possibles</h3>
          </section>

          <section>
            <h3>Présentation formelle des problèmes</h3>
          </section>

          <section>
            <h3>Calculer $\mathcal{F}$ : état de l'art</h3>

            <style type="text/css">
              .table td {
                border-top: 1px solid black;
                padding: 10px;
              }
            </style>

            <br>

            <small>
              <table class="table">
                <thead>
                  <th>Solution</th>
                  <th>Espace (bits)</th>
                  <th>Temps</th>
                </thead>
                <tr>
                  <td>Various Impr. to T. F. (Monte-Carlo)</td>
                  <td>$\mathcal{O}((n + |\mathcal{F}|)$ $log$ $n)$</td>
                  <td>$\mathcal{O}(n + |\mathcal{L}|)$</td>
                </tr>
                <tr>
                  <td>Faster T. F.</td>
                  <td>$\mathcal{O}((n + |\mathcal{L}_{\mathcal{C}}| + |\mathcal{F}|$ $log$ $|\Sigma|)$ $log$ $n)$</td>
                  <td>$\mathcal{O}(n + |\mathcal{L}_{\mathcal{C}}|$ $log$ $|\Sigma|)$</td>
                </tr>
                <tr>
                  <td>New Algorithms for T. F.</td>
                  <td>$\mathcal{O}((n + |\mathcal{L}|)$ $log$ $n)$</td>
                  <td>$\mathcal{O}(n + |\mathcal{L}|$ $log$ $|\Sigma|)$</td>
                </tr>
                <tr>
                  <td>Efficient T. F. via Parikh Mapping</td>
                  <td>$\mathcal{O}(n|\Sigma|log$ $n$ $log$ $|\Sigma|)$</td>
                  <td></td>
                </tr>
              </table>
            </small>
          </section>

          <section>
            <h3>Locations maximales</h3>

            <ul>
              <li>On note $\mathcal{C}$ un ensemble de lettres de $\Sigma$. Une location maximale de $\mathcal{C}$ dans $s$ est un intervalle $[i,j]$ tel que :<br>
                <br>
                <ul>
                  <li>$\mathcal{C}_{s}(i,j) = \mathcal{C}$</li>
                  <li>Si $i > 1$, $s_{i-1} \notin$ $\mathcal{C}_{s}(i,j)$</li>
                  <li>Si $j < n$, $s_{j+1} \notin$ $\mathcal{C}_{s}(i,j)$</li>
                </ul><br>
              </li>
              <li>On note $\mathcal{L}$ l'ensemble des locations maximales de tous les fingerprints de $\mathcal{F}$</li>
            </ul>
          </section>

          <section>
            <h3>Exemple</h3>
            <br>
            $s = a_{1} b_{2} c_{3} a_{4} a_{5} d_{6} d_{7} b_{8}$<br>
            <br>
            $\mathcal{C} = abc$<br>
            <br>
            Locations maximales : {$\langle1,5\rangle$}
          </section>

          <section>
            <h3>Copies</h3>

            <br>

            <ul>
              <li>Deux locations maximales $\langle i,j \rangle$ et $\langle k,l \rangle$ de $s$ sont des copies si $s_{i}..s_{j} = s_{k}..s_{l}$</li>
              <li>On note $\mathcal{L}_{\mathcal{C}}$ l'ensemble des classes d'équivalence</li>
            </ul>
          </section>

          <section>
            <h3>Exemple</h3>
            <br>
            $s = a_{1} b_{2} a_{3} d_{4} a_{5} b_{6} a_{7}$<br>
            <br>
            $\langle1,3\rangle$ et $\langle5,7\rangle$ sont des copies
          </section>


<!--

*** TODO état de l'art sur le calcul de F
    (inliner les defs nécessaires)
    (complexités)
*** TODO méthode introduite dans l'article (intuition méthodes précendentes vs cet article)
    (par opposition au tableau + liste changements)
    (ne pas recalculer les parties redondantes des fp)
*** TODO vue d'ensemble de la méthode
    - construire PT
    - nommer PT
    - …
    - profit -->
          <section>
            <h3>Vue d'ensemble de la méthode</h3>

          	<ul>
			  <li>Construire l'arbre des suffixes de $s$</li>
			  <li>À partir de l'arbre des suffixes, construire un arbre des participations</li>
			  <li>À partir de l'arbre des participations, nommer et retourner tous les fingerprints de $s$</li>
          	</ul>
          </section>
        </section>

        <section>
          <section data-state="submerge">
            <h1>Participation Tree</h1>
          </section>
          <section>
            <h3>Principes</h3>

            <ul>
            	<li>Noté $PT$</li>
            	<li>Construit à partir de l'arbre des suffixes de $s$</li>
            	<li>Contient l'ensemble des fingerprints $f$ de $\mathcal{F}$</li>
            </ul>
          </section>
          
          <section>
            <h3>Construction de l'arbre</h3>
          </section>
          
          <section>
            <h3>Théorème</h3>

            $\Phi$ étant définie comme une fonction retournant l'ensemble des locations maximales correspondant à un chemin $z$ de $PT$,<br>
            <br>
            <strong>toutes les locations maximales sont dans l'image $\Phi(z)$ d'un chemin $z$ dans $PT(s = s_{1}..s_{n})$, et la taille de $PT(s)$ est $\mathcal{O}(|\mathcal{L}_{\mathcal{C}}|)$</strong>
          </section>
          
          <section>
            <h3>Transformer le ST en PT</h3>
          </section>
        </section>

        
        <section>
          <section data-state="sunset">
            <h1>Nommage des <span>fingerprints</span></h1>
          </section>

          <section>
            <h3>Nommage d'une fingerprint</h3>
          </section>

          <section>
            <h3>Nommage basique (2003)</h3>
          </section>

          <section>
            <h3>Nommage par changements</h3>
          </section>

          <section>
            <h3>Nommage sur l'arbre</h3>
          </section>
        </section>
        
        <section data-state="cobalt">
          <h1>Conclusion</h1>
        </section>
      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>
      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
      controls: true,
      progress: true,
      history: true,
      center: true,

      theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
      transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/fade/none

      math: {
      mathjax: 'http://cdn.mathjax.org/mathjax/latest/MathJax.js',
      config: 'TeX-AMS_HTML-full' // See http://docs.mathjax.org/en/latest/config-files.html
      },
      // Parallax scrolling
      // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
      // parallaxBackgroundSize: '2100px 900px',

      // Optional libraries used to extend on reveal.js
      dependencies: [{
      src: 'lib/js/classList.js',
      condition: function() {
      return !document.body.classList;
      }
      }, {
      src: 'plugin/markdown/marked.js',
      condition: function() {
      return !!document.querySelector('[data-markdown]');
      }
      }, {
      src: 'plugin/markdown/markdown.js',
      condition: function() {
      return !!document.querySelector('[data-markdown]');
      }
      }, {
      src: 'plugin/highlight/highlight.js',
      async: true,
      callback: function() {
      hljs.initHighlightingOnLoad();
      }
      }, {
      src: 'plugin/zoom-js/zoom.js',
      async: true,
      condition: function() {
      return !!document.body.classList;
      }
      }, {
      src: 'plugin/notes/notes.js',
      async: true,
      condition: function() {
      return !!document.body.classList;
      }
      }, {
      src: 'plugin/math/math.js',
      async: true
      }]
      });
    </script>

  </body>

</html>
